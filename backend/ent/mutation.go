// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"

	"github.com/Pichais/app/ent/organ"
	"github.com/Pichais/app/ent/physician"
	"github.com/Pichais/app/ent/spaciality"
	"github.com/Pichais/app/ent/typedisease"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeOrgan       = "Organ"
	TypePhysician   = "Physician"
	TypeSpaciality  = "Spaciality"
	TypeTypeDisease = "TypeDisease"
)

// OrganMutation represents an operation that mutate the Organs
// nodes in the graph.
type OrganMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_OrganName     *string
	clearedFields  map[string]struct{}
	forogan        map[int]struct{}
	removedforogan map[int]struct{}
	done           bool
	oldValue       func(context.Context) (*Organ, error)
}

var _ ent.Mutation = (*OrganMutation)(nil)

// organOption allows to manage the mutation configuration using functional options.
type organOption func(*OrganMutation)

// newOrganMutation creates new mutation for $n.Name.
func newOrganMutation(c config, op Op, opts ...organOption) *OrganMutation {
	m := &OrganMutation{
		config:        c,
		op:            op,
		typ:           TypeOrgan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrganID sets the id field of the mutation.
func withOrganID(id int) organOption {
	return func(m *OrganMutation) {
		var (
			err   error
			once  sync.Once
			value *Organ
		)
		m.oldValue = func(ctx context.Context) (*Organ, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Organ.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrgan sets the old Organ of the mutation.
func withOrgan(node *Organ) organOption {
	return func(m *OrganMutation) {
		m.oldValue = func(context.Context) (*Organ, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrganMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrganMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *OrganMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetOrganName sets the OrganName field.
func (m *OrganMutation) SetOrganName(s string) {
	m._OrganName = &s
}

// OrganName returns the OrganName value in the mutation.
func (m *OrganMutation) OrganName() (r string, exists bool) {
	v := m._OrganName
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganName returns the old OrganName value of the Organ.
// If the Organ object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OrganMutation) OldOrganName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrganName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrganName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganName: %w", err)
	}
	return oldValue.OrganName, nil
}

// ResetOrganName reset all changes of the "OrganName" field.
func (m *OrganMutation) ResetOrganName() {
	m._OrganName = nil
}

// AddForoganIDs adds the forogan edge to Spaciality by ids.
func (m *OrganMutation) AddForoganIDs(ids ...int) {
	if m.forogan == nil {
		m.forogan = make(map[int]struct{})
	}
	for i := range ids {
		m.forogan[ids[i]] = struct{}{}
	}
}

// RemoveForoganIDs removes the forogan edge to Spaciality by ids.
func (m *OrganMutation) RemoveForoganIDs(ids ...int) {
	if m.removedforogan == nil {
		m.removedforogan = make(map[int]struct{})
	}
	for i := range ids {
		m.removedforogan[ids[i]] = struct{}{}
	}
}

// RemovedForogan returns the removed ids of forogan.
func (m *OrganMutation) RemovedForoganIDs() (ids []int) {
	for id := range m.removedforogan {
		ids = append(ids, id)
	}
	return
}

// ForoganIDs returns the forogan ids in the mutation.
func (m *OrganMutation) ForoganIDs() (ids []int) {
	for id := range m.forogan {
		ids = append(ids, id)
	}
	return
}

// ResetForogan reset all changes of the "forogan" edge.
func (m *OrganMutation) ResetForogan() {
	m.forogan = nil
	m.removedforogan = nil
}

// Op returns the operation name.
func (m *OrganMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Organ).
func (m *OrganMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *OrganMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._OrganName != nil {
		fields = append(fields, organ.FieldOrganName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *OrganMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case organ.FieldOrganName:
		return m.OrganName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *OrganMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case organ.FieldOrganName:
		return m.OldOrganName(ctx)
	}
	return nil, fmt.Errorf("unknown Organ field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OrganMutation) SetField(name string, value ent.Value) error {
	switch name {
	case organ.FieldOrganName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganName(v)
		return nil
	}
	return fmt.Errorf("unknown Organ field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *OrganMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *OrganMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OrganMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Organ numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *OrganMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *OrganMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrganMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Organ nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *OrganMutation) ResetField(name string) error {
	switch name {
	case organ.FieldOrganName:
		m.ResetOrganName()
		return nil
	}
	return fmt.Errorf("unknown Organ field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *OrganMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.forogan != nil {
		edges = append(edges, organ.EdgeForogan)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *OrganMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case organ.EdgeForogan:
		ids := make([]ent.Value, 0, len(m.forogan))
		for id := range m.forogan {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *OrganMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedforogan != nil {
		edges = append(edges, organ.EdgeForogan)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *OrganMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case organ.EdgeForogan:
		ids := make([]ent.Value, 0, len(m.removedforogan))
		for id := range m.removedforogan {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *OrganMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *OrganMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *OrganMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Organ unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *OrganMutation) ResetEdge(name string) error {
	switch name {
	case organ.EdgeForogan:
		m.ResetForogan()
		return nil
	}
	return fmt.Errorf("unknown Organ edge %s", name)
}

// PhysicianMutation represents an operation that mutate the Physicians
// nodes in the graph.
type PhysicianMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_PhysicianName  *string
	_PhysicianEmail *string
	clearedFields   map[string]struct{}
	foruser         map[int]struct{}
	removedforuser  map[int]struct{}
	done            bool
	oldValue        func(context.Context) (*Physician, error)
}

var _ ent.Mutation = (*PhysicianMutation)(nil)

// physicianOption allows to manage the mutation configuration using functional options.
type physicianOption func(*PhysicianMutation)

// newPhysicianMutation creates new mutation for $n.Name.
func newPhysicianMutation(c config, op Op, opts ...physicianOption) *PhysicianMutation {
	m := &PhysicianMutation{
		config:        c,
		op:            op,
		typ:           TypePhysician,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPhysicianID sets the id field of the mutation.
func withPhysicianID(id int) physicianOption {
	return func(m *PhysicianMutation) {
		var (
			err   error
			once  sync.Once
			value *Physician
		)
		m.oldValue = func(ctx context.Context) (*Physician, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Physician.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPhysician sets the old Physician of the mutation.
func withPhysician(node *Physician) physicianOption {
	return func(m *PhysicianMutation) {
		m.oldValue = func(context.Context) (*Physician, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PhysicianMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PhysicianMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PhysicianMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPhysicianName sets the PhysicianName field.
func (m *PhysicianMutation) SetPhysicianName(s string) {
	m._PhysicianName = &s
}

// PhysicianName returns the PhysicianName value in the mutation.
func (m *PhysicianMutation) PhysicianName() (r string, exists bool) {
	v := m._PhysicianName
	if v == nil {
		return
	}
	return *v, true
}

// OldPhysicianName returns the old PhysicianName value of the Physician.
// If the Physician object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PhysicianMutation) OldPhysicianName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhysicianName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhysicianName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhysicianName: %w", err)
	}
	return oldValue.PhysicianName, nil
}

// ResetPhysicianName reset all changes of the "PhysicianName" field.
func (m *PhysicianMutation) ResetPhysicianName() {
	m._PhysicianName = nil
}

// SetPhysicianEmail sets the PhysicianEmail field.
func (m *PhysicianMutation) SetPhysicianEmail(s string) {
	m._PhysicianEmail = &s
}

// PhysicianEmail returns the PhysicianEmail value in the mutation.
func (m *PhysicianMutation) PhysicianEmail() (r string, exists bool) {
	v := m._PhysicianEmail
	if v == nil {
		return
	}
	return *v, true
}

// OldPhysicianEmail returns the old PhysicianEmail value of the Physician.
// If the Physician object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PhysicianMutation) OldPhysicianEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhysicianEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhysicianEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhysicianEmail: %w", err)
	}
	return oldValue.PhysicianEmail, nil
}

// ResetPhysicianEmail reset all changes of the "PhysicianEmail" field.
func (m *PhysicianMutation) ResetPhysicianEmail() {
	m._PhysicianEmail = nil
}

// AddForuserIDs adds the foruser edge to Spaciality by ids.
func (m *PhysicianMutation) AddForuserIDs(ids ...int) {
	if m.foruser == nil {
		m.foruser = make(map[int]struct{})
	}
	for i := range ids {
		m.foruser[ids[i]] = struct{}{}
	}
}

// RemoveForuserIDs removes the foruser edge to Spaciality by ids.
func (m *PhysicianMutation) RemoveForuserIDs(ids ...int) {
	if m.removedforuser == nil {
		m.removedforuser = make(map[int]struct{})
	}
	for i := range ids {
		m.removedforuser[ids[i]] = struct{}{}
	}
}

// RemovedForuser returns the removed ids of foruser.
func (m *PhysicianMutation) RemovedForuserIDs() (ids []int) {
	for id := range m.removedforuser {
		ids = append(ids, id)
	}
	return
}

// ForuserIDs returns the foruser ids in the mutation.
func (m *PhysicianMutation) ForuserIDs() (ids []int) {
	for id := range m.foruser {
		ids = append(ids, id)
	}
	return
}

// ResetForuser reset all changes of the "foruser" edge.
func (m *PhysicianMutation) ResetForuser() {
	m.foruser = nil
	m.removedforuser = nil
}

// Op returns the operation name.
func (m *PhysicianMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Physician).
func (m *PhysicianMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PhysicianMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._PhysicianName != nil {
		fields = append(fields, physician.FieldPhysicianName)
	}
	if m._PhysicianEmail != nil {
		fields = append(fields, physician.FieldPhysicianEmail)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PhysicianMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case physician.FieldPhysicianName:
		return m.PhysicianName()
	case physician.FieldPhysicianEmail:
		return m.PhysicianEmail()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PhysicianMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case physician.FieldPhysicianName:
		return m.OldPhysicianName(ctx)
	case physician.FieldPhysicianEmail:
		return m.OldPhysicianEmail(ctx)
	}
	return nil, fmt.Errorf("unknown Physician field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PhysicianMutation) SetField(name string, value ent.Value) error {
	switch name {
	case physician.FieldPhysicianName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhysicianName(v)
		return nil
	case physician.FieldPhysicianEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhysicianEmail(v)
		return nil
	}
	return fmt.Errorf("unknown Physician field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PhysicianMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PhysicianMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PhysicianMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Physician numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PhysicianMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PhysicianMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PhysicianMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Physician nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PhysicianMutation) ResetField(name string) error {
	switch name {
	case physician.FieldPhysicianName:
		m.ResetPhysicianName()
		return nil
	case physician.FieldPhysicianEmail:
		m.ResetPhysicianEmail()
		return nil
	}
	return fmt.Errorf("unknown Physician field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PhysicianMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.foruser != nil {
		edges = append(edges, physician.EdgeForuser)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PhysicianMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case physician.EdgeForuser:
		ids := make([]ent.Value, 0, len(m.foruser))
		for id := range m.foruser {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PhysicianMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedforuser != nil {
		edges = append(edges, physician.EdgeForuser)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PhysicianMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case physician.EdgeForuser:
		ids := make([]ent.Value, 0, len(m.removedforuser))
		for id := range m.removedforuser {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PhysicianMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PhysicianMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PhysicianMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Physician unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PhysicianMutation) ResetEdge(name string) error {
	switch name {
	case physician.EdgeForuser:
		m.ResetForuser()
		return nil
	}
	return fmt.Errorf("unknown Physician edge %s", name)
}

// SpacialityMutation represents an operation that mutate the Spacialities
// nodes in the graph.
type SpacialityMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	ogan          *int
	clearedogan   bool
	_type         *int
	cleared_type  bool
	done          bool
	oldValue      func(context.Context) (*Spaciality, error)
}

var _ ent.Mutation = (*SpacialityMutation)(nil)

// spacialityOption allows to manage the mutation configuration using functional options.
type spacialityOption func(*SpacialityMutation)

// newSpacialityMutation creates new mutation for $n.Name.
func newSpacialityMutation(c config, op Op, opts ...spacialityOption) *SpacialityMutation {
	m := &SpacialityMutation{
		config:        c,
		op:            op,
		typ:           TypeSpaciality,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpacialityID sets the id field of the mutation.
func withSpacialityID(id int) spacialityOption {
	return func(m *SpacialityMutation) {
		var (
			err   error
			once  sync.Once
			value *Spaciality
		)
		m.oldValue = func(ctx context.Context) (*Spaciality, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Spaciality.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpaciality sets the old Spaciality of the mutation.
func withSpaciality(node *Spaciality) spacialityOption {
	return func(m *SpacialityMutation) {
		m.oldValue = func(context.Context) (*Spaciality, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpacialityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpacialityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SpacialityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUserID sets the user edge to Physician by id.
func (m *SpacialityMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the user edge to Physician.
func (m *SpacialityMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *SpacialityMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *SpacialityMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SpacialityMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *SpacialityMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetOganID sets the ogan edge to Organ by id.
func (m *SpacialityMutation) SetOganID(id int) {
	m.ogan = &id
}

// ClearOgan clears the ogan edge to Organ.
func (m *SpacialityMutation) ClearOgan() {
	m.clearedogan = true
}

// OganCleared returns if the edge ogan was cleared.
func (m *SpacialityMutation) OganCleared() bool {
	return m.clearedogan
}

// OganID returns the ogan id in the mutation.
func (m *SpacialityMutation) OganID() (id int, exists bool) {
	if m.ogan != nil {
		return *m.ogan, true
	}
	return
}

// OganIDs returns the ogan ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OganID instead. It exists only for internal usage by the builders.
func (m *SpacialityMutation) OganIDs() (ids []int) {
	if id := m.ogan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOgan reset all changes of the "ogan" edge.
func (m *SpacialityMutation) ResetOgan() {
	m.ogan = nil
	m.clearedogan = false
}

// SetTypeID sets the type edge to TypeDisease by id.
func (m *SpacialityMutation) SetTypeID(id int) {
	m._type = &id
}

// ClearType clears the type edge to TypeDisease.
func (m *SpacialityMutation) ClearType() {
	m.cleared_type = true
}

// TypeCleared returns if the edge type was cleared.
func (m *SpacialityMutation) TypeCleared() bool {
	return m.cleared_type
}

// TypeID returns the type id in the mutation.
func (m *SpacialityMutation) TypeID() (id int, exists bool) {
	if m._type != nil {
		return *m._type, true
	}
	return
}

// TypeIDs returns the type ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// TypeID instead. It exists only for internal usage by the builders.
func (m *SpacialityMutation) TypeIDs() (ids []int) {
	if id := m._type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetType reset all changes of the "type" edge.
func (m *SpacialityMutation) ResetType() {
	m._type = nil
	m.cleared_type = false
}

// Op returns the operation name.
func (m *SpacialityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Spaciality).
func (m *SpacialityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SpacialityMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SpacialityMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SpacialityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Spaciality field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SpacialityMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Spaciality field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SpacialityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SpacialityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SpacialityMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Spaciality numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SpacialityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SpacialityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpacialityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Spaciality nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SpacialityMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Spaciality field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SpacialityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, spaciality.EdgeUser)
	}
	if m.ogan != nil {
		edges = append(edges, spaciality.EdgeOgan)
	}
	if m._type != nil {
		edges = append(edges, spaciality.EdgeType)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SpacialityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case spaciality.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case spaciality.EdgeOgan:
		if id := m.ogan; id != nil {
			return []ent.Value{*id}
		}
	case spaciality.EdgeType:
		if id := m._type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SpacialityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SpacialityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SpacialityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, spaciality.EdgeUser)
	}
	if m.clearedogan {
		edges = append(edges, spaciality.EdgeOgan)
	}
	if m.cleared_type {
		edges = append(edges, spaciality.EdgeType)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SpacialityMutation) EdgeCleared(name string) bool {
	switch name {
	case spaciality.EdgeUser:
		return m.cleareduser
	case spaciality.EdgeOgan:
		return m.clearedogan
	case spaciality.EdgeType:
		return m.cleared_type
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SpacialityMutation) ClearEdge(name string) error {
	switch name {
	case spaciality.EdgeUser:
		m.ClearUser()
		return nil
	case spaciality.EdgeOgan:
		m.ClearOgan()
		return nil
	case spaciality.EdgeType:
		m.ClearType()
		return nil
	}
	return fmt.Errorf("unknown Spaciality unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SpacialityMutation) ResetEdge(name string) error {
	switch name {
	case spaciality.EdgeUser:
		m.ResetUser()
		return nil
	case spaciality.EdgeOgan:
		m.ResetOgan()
		return nil
	case spaciality.EdgeType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown Spaciality edge %s", name)
}

// TypeDiseaseMutation represents an operation that mutate the TypeDiseases
// nodes in the graph.
type TypeDiseaseMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_DiseaseName   *string
	clearedFields  map[string]struct{}
	fortype        map[int]struct{}
	removedfortype map[int]struct{}
	done           bool
	oldValue       func(context.Context) (*TypeDisease, error)
}

var _ ent.Mutation = (*TypeDiseaseMutation)(nil)

// typediseaseOption allows to manage the mutation configuration using functional options.
type typediseaseOption func(*TypeDiseaseMutation)

// newTypeDiseaseMutation creates new mutation for $n.Name.
func newTypeDiseaseMutation(c config, op Op, opts ...typediseaseOption) *TypeDiseaseMutation {
	m := &TypeDiseaseMutation{
		config:        c,
		op:            op,
		typ:           TypeTypeDisease,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTypeDiseaseID sets the id field of the mutation.
func withTypeDiseaseID(id int) typediseaseOption {
	return func(m *TypeDiseaseMutation) {
		var (
			err   error
			once  sync.Once
			value *TypeDisease
		)
		m.oldValue = func(ctx context.Context) (*TypeDisease, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TypeDisease.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTypeDisease sets the old TypeDisease of the mutation.
func withTypeDisease(node *TypeDisease) typediseaseOption {
	return func(m *TypeDiseaseMutation) {
		m.oldValue = func(context.Context) (*TypeDisease, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TypeDiseaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TypeDiseaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *TypeDiseaseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDiseaseName sets the DiseaseName field.
func (m *TypeDiseaseMutation) SetDiseaseName(s string) {
	m._DiseaseName = &s
}

// DiseaseName returns the DiseaseName value in the mutation.
func (m *TypeDiseaseMutation) DiseaseName() (r string, exists bool) {
	v := m._DiseaseName
	if v == nil {
		return
	}
	return *v, true
}

// OldDiseaseName returns the old DiseaseName value of the TypeDisease.
// If the TypeDisease object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *TypeDiseaseMutation) OldDiseaseName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiseaseName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiseaseName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiseaseName: %w", err)
	}
	return oldValue.DiseaseName, nil
}

// ResetDiseaseName reset all changes of the "DiseaseName" field.
func (m *TypeDiseaseMutation) ResetDiseaseName() {
	m._DiseaseName = nil
}

// AddFortypeIDs adds the fortype edge to Spaciality by ids.
func (m *TypeDiseaseMutation) AddFortypeIDs(ids ...int) {
	if m.fortype == nil {
		m.fortype = make(map[int]struct{})
	}
	for i := range ids {
		m.fortype[ids[i]] = struct{}{}
	}
}

// RemoveFortypeIDs removes the fortype edge to Spaciality by ids.
func (m *TypeDiseaseMutation) RemoveFortypeIDs(ids ...int) {
	if m.removedfortype == nil {
		m.removedfortype = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfortype[ids[i]] = struct{}{}
	}
}

// RemovedFortype returns the removed ids of fortype.
func (m *TypeDiseaseMutation) RemovedFortypeIDs() (ids []int) {
	for id := range m.removedfortype {
		ids = append(ids, id)
	}
	return
}

// FortypeIDs returns the fortype ids in the mutation.
func (m *TypeDiseaseMutation) FortypeIDs() (ids []int) {
	for id := range m.fortype {
		ids = append(ids, id)
	}
	return
}

// ResetFortype reset all changes of the "fortype" edge.
func (m *TypeDiseaseMutation) ResetFortype() {
	m.fortype = nil
	m.removedfortype = nil
}

// Op returns the operation name.
func (m *TypeDiseaseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TypeDisease).
func (m *TypeDiseaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *TypeDiseaseMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._DiseaseName != nil {
		fields = append(fields, typedisease.FieldDiseaseName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *TypeDiseaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case typedisease.FieldDiseaseName:
		return m.DiseaseName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *TypeDiseaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case typedisease.FieldDiseaseName:
		return m.OldDiseaseName(ctx)
	}
	return nil, fmt.Errorf("unknown TypeDisease field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TypeDiseaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case typedisease.FieldDiseaseName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiseaseName(v)
		return nil
	}
	return fmt.Errorf("unknown TypeDisease field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *TypeDiseaseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *TypeDiseaseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *TypeDiseaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TypeDisease numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *TypeDiseaseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *TypeDiseaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *TypeDiseaseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TypeDisease nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *TypeDiseaseMutation) ResetField(name string) error {
	switch name {
	case typedisease.FieldDiseaseName:
		m.ResetDiseaseName()
		return nil
	}
	return fmt.Errorf("unknown TypeDisease field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *TypeDiseaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.fortype != nil {
		edges = append(edges, typedisease.EdgeFortype)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *TypeDiseaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case typedisease.EdgeFortype:
		ids := make([]ent.Value, 0, len(m.fortype))
		for id := range m.fortype {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *TypeDiseaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedfortype != nil {
		edges = append(edges, typedisease.EdgeFortype)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *TypeDiseaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case typedisease.EdgeFortype:
		ids := make([]ent.Value, 0, len(m.removedfortype))
		for id := range m.removedfortype {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *TypeDiseaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *TypeDiseaseMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *TypeDiseaseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown TypeDisease unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *TypeDiseaseMutation) ResetEdge(name string) error {
	switch name {
	case typedisease.EdgeFortype:
		m.ResetFortype()
		return nil
	}
	return fmt.Errorf("unknown TypeDisease edge %s", name)
}
